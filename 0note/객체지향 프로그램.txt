java, c++

===> 객체 지향 프로그래밍
===> Object Oriented Programming
===> OOP


===> 어떤 (공공기관, 기업) 요구조건을 처리를 위한
	시스템 개발을 위한 일처리를 위해 
	필요한 데이터와 기능을 분석하여
	객체화 하여 처리하는 방식을 말한다.



===> 현시세계의 모든 것을 객체화 할 수 있다.

객체!

이원우가 손에 갤럭시10을 들고 이스트백을 메고 은행에 들어간다.

사람(클래스){
		손 
		든다
		멘다
		들어간다
		}



자바로 객체지향 프로그램을 위해서는
	주어진 문제를 표현하기 위한
	객체에 대하여 
		속성과 동작을 분석한다.

		그 객체를 표현하기 위한
		속성과 동작을 갖는 클래스를 만들어요!


------------------<< 메소드(Method) >>---------------------
==> 어떤 일 처리를 위한 서로 관련있는 명령들의 집합.
	(서로 연관된 코드를 그룹핑해서 이름을 붙인 정리정돈의 상자다.)

<<메소드 호출 방식>>
1. 값에 의한 호출(call by value)	=>기본자료형(int boolean double등등
==> 메소드 호출시에 전달해준 값이 메소드안에서 변경되더라도 
	변경된 내용이 메소드 호출한 쪽에서 반영되지 않아요!

===> 메소드 호출시에 기본자료형을 전달 해 주는것은
	모두 값에 의한 호출입니다.


2. 참조에 의한 호출(call by reference)	=>참조자료형(배열등등
==> 메소드 호출시에 전달해준 값이 메소드안에서 변경될때
	변경된 내용이 메소드 호출한 쪽에서 반영되어요!

===> 메소드 호출시에 
	배열이나 객체를 전달하는것은 
	모두 참조에의한 호출입니다.


** 메소드 return 값은 여러개 일 수 있다.
	거짓! 
	ex) public int Pro(){
	return a, b, c --->(X)}

** 그럼 어떡해요??
	나는 여러개를 return하고 싶어요!
	==> 한덩어리로 만들어요
		(클래스, List)

==============********===============================================
서로 연관된 변수와 메소드를 그룹핑한것이다. 거기에 이름을 붙인것. 정리정돈의 상자.
클래스 {
	속성		: 멤버 변수
	동작(기능)	: 멤버 메소드}

=====================================================================

사람 Person
	속성
		이름		String name;	"이수인"
		성별		String gender;	"여자"
		나이		int age;	20;


	동작
		먹는다		void eat(String food)
		잠을잔다	void sleep()

=====================================================================

<< 객체지향 프로그래밍의 특징 >>
1. 은닉성 : encapsulation(속성을 보호한다)
	
		접근명시자 : 
			1. private
			2. piblic
			/3. protected
			/4. _______(접근명시자가 없는것도 있다)

	일반적으로 클래스의 멤버변수들은
		외부로 노출하지 않도록 private영역에 두고		---->외부에서 정보를 바꾸거나 얻고싶다면
		public인 메소드를 통해서 접근할 수 있도록 만들어요!		set,get을 해주어야함! 객체지향적으로 하고싶다면 기본적으로 setter getter만들어주자
				

			
	

2. 상속성	밑에있음.
3. 다형성	다음시간에~

=====================================================================
<< 생성자(Constructor) >>
클래스 이름과 같은 이름을 갖는 특별한 메소드를 말한다.
객체 생성시에 자동 수행되어 속성(멤버변수)들의 값을 
초기화 할 목적으로 사용합니다.

생성자는 일반 메소드처럼 호출문에 의해서 동작하지 않고
	객체 생성시에 자동 수행됩니다.

	==>	따라서 return의 개념이 없어요.(호출문은 생략된거고 생성자는 아예 없는것)
		생성자 앞에 return type을 적지않아요!!!!
		void라고 적으면 절대 안됩니다!!!!

		
<< this. >>
	생성자나 메소드의 매개변수이름을 의미 있는 이름으로 
	정해 주다 보면 속성(멤버변수)이름과 같아져요.
	이때 속성(멤버변수)자신을 구별할 목적으로
	this.를 사용합니다.

	this.변수명
	this.width


<< 생성자의 중복(overloading) >>==================================

	때에 따라 필요하다면 생성자를 중복하여 정의할 수 있어요!
	생성자를 중복정의하려면 다음의 조건을 만족해야 해요!
	==>생성자의 매개변수의 개수나 자료형이 달라야함. (day1216 / RectangleTest 안에 내용있음)

Person(){}
Person(String name, int age){}
Person(String name){}
Person(int age){}
Person(String addr){}	==> 불가함. 같은 자료형String 1개를 가진 생성자가 이미 있음.


================================================================================
		*** 생성자를 만들때 기본생성자를 꼭 만들어놓자 ***
<< 생성자가 삐져요! >>
만약 사용자가 생성자를 하나도 만들지 않으면 
	자바는 기본생성자(매개변수를 하나도 갖지 않는 생성자)를 제공합니다.

그러나 만약 사용자가 생성자를 정의하기 시작하면(만든다면)
	더이상 기본 생성자를 제공하지 않아요!



필요하다면 사용자가 기본생성자를 만들어야 해요!(항상 기본으로 세트를 만들어주자)

////////////////////////////////////////////////////////////////////////////////


<< 메소드의 중복(overloading) >>==============================================
	
	동일한 이름의 메소드를 중복 정의할 수 있어요!
	이것을 만족하기 위해서는 매개변수의 개수가 다르거나 자료형이 달라야 해요.


	

<< 클래스 변수 >>
	정적변수(static변수) ==> 객체없이 사용가능함 

	클래스의 멤버변수들은 일반적으로 객체를 생성해야지만 메모리가 확보되고 
					(~ ~= new ~();)
				(클래스 이름=new 클래스();) 클래스는 자료형과 같은 레벨.
	그리고 객체마다 별도의 메모리 공간을 갖습니다.
	또, 그것을 사용하기 위해서는 반드시 객체를 통해서 사용할 수 있어요.

	그런데 만약,
	모든 객체가 공동으로 사용할 기억공간이 필요하다면 
	혹은, 객체 없이도 사용할 기억공간이 필요하다면
	클래스 변수를 사용해요!
	멤버변수명 앞에 static 키워드를 붙이면 이것이 클래스변수(정적변수)라고
	하고 객체를 생성하지 않아도 프로그램 실행하면 가장먼저 메모리가 확보됩니다.
	그래서----------->객체없이도 사용할 수 있어요. new가 없음!!!
			->클래스 이름으로 접근합니다
			->만약 객체가 있다면 객체를 통해서도 접근할 수 있어요.


ex) StaticTest
클래스의 멤버변수 = name,age
클래스변수 (public static String addr;) = addr
객체없이 클래스이름 = Family.addr="서울시 서대문구 홍제동";


<< 클래스 메소드 >>
	일반적으로 어떤 클래스의 멤버메소드를 사용하기 위해서는
	반드시 그 클래스의 객체를 생성하고 객체를 통해서만 사용할 수 있어요.

	그런데 만약 객체없이도 어떤 메소드를
	사용하도록 하려면 메소드 이름앞에 static 키워드를 붙여
	클래스 메소드를 만들어요!

	객체없이 접근해야 하니 클래스 이름으로 접근해요.
	아님 객체가 있다면 객체를 통해서도 접근할 수 있어요.

######################## 중요! ########################
클래스 메소드 안에서는 클래스 맴버에만 접근 할 수 있어요!
객체를 생성해야지만 사용할 수 있는 일밤 멤버에는 접근 할 수 없어요!



=======================================================================
<< 클래스이름 앞에 public >>
==> 클래스이름앞에는 public접근 명시자만 올수 있어요.
	private, protected등은 올 수 없어요!
즉, 클래스 이름 앞에는 public 접근명시자를 붙이거나 생략하는 두가지 경우가 있어요!
클래스 이름앞에 접근명시자가 생략된 것은
	friendly의 개념입니다.
	friendly란 이 클래스가 속해 있는 동일한 패키지(폴더)는
	모두 친구로 생각하여 이 클래스를 사용할 수 있음을 나타냅니다.
		
	만약 이 클래스를 외부의 다른 패키지(폴더)에서도 
	사용할 수 있도록 하려면 public접근명시자를 붙여요.
=======================================================================

일반적으로 하나의 파일에는
	하나의 클래스만 만들어요.
	그래서 외부의 클래스로 부터 사용을 허용하느냐에 따라
	public을 붙이거나 
	혹은 생략해요!

=======================================================================

***만약 하나의 파일에 
	여러개의 클래스를 정의한다면
	main메소드를 포함한 클래스이름으로 
	파일명을 정해줘요
	==> 쓰고싶은 main을 클래스네임을 파일명으로 해서 컴파일해야 실행할 수 있음!

=======================================================================

2. 상속성 : Inheritance
	이미 만들어둔 클래스를 확장하여 새로운 클래스를 만들 수 있어요!

<< protedted >>========================================================
	상속관계에 있는 자식클래스라 하더라도
	부모클래스의 private영역에는 접근할 수 없어요
		오류명 --> error: name has private access in Human
			   this.name=name;
	만약, 외부의 다른클래스로 부터는 보호하되
	상속받는 자식클래스에게는 접근을 허용하고자 한다면
	protected 접근명시자를 사용해요!

<< method overriding >>================================================
상속관계에 있을때 부모로 부터 물려받은 method가
자식클래스에세는 맞지 않아 다시 정의하는 것을 말합니다==>재정의

메소드 오버라이팅이 되기 위해서는
메소드 이름뿐 아니라 매개변수의 개수와 자료형 까지 일치되게 재정의 되어야 합니다.

상속받은 자식클래스는 부모의 모든 속성과 동작을
마치 자신의 것 처럼 사용할 수 있어요.

만약 부모로부터 물려 받은 기능(메소드)이 자신에게도 알맞다면
그대로 사용할수 있고
자신에게 만약 맞지않다면 재정의 하여 사용할 수 있어요.(선택권이 있다)
======>	자식의 입장에서 선택할 수 있어요.
	(오버라이딩 할지, 말지)

미래의 만들어질 후손 클래스들이 가져야 할 속성들과 동작들을 미리 뽑아서 동작시킬 수 있어요.
======> 부모클래스를 만들어요

이때 부모클래스를 만드는 과정에서 
미래에 만들어질 후손클래스들이 반드시 가져야하는 동작(메소드)이 있는데 
그것이 body를 구체화 할 수 없어요.
	예를들어 모든2차원 도형들이 가져야 할 속성돠 동작을 뽑아서
	Shape이라는 이름의 클래스를 만드는 과정에서
	모든 2차원 도형은 면적을 계산하여 aclcArea라는 메소드가 필요해요.
	그런데 이게 "원"이 될지 "사각형"이 될지 "삼각형"이 될지 아직 몰라요.
	이 모르는 상태에서 aclcArea 메소드의 몸통(body)를 구페화 할 수 없어요.

	다음과 method의 body를 쓰되 내용을 채우지 않았어요.
	upblic void calcArea(){
	
	}

	위와 같이 두게 되면
	후손들에게 선택의 자유를 주게 됩니다.
	오버라이딩 해도되고, 말아도되고,
	만약, 선택의 자유를 주지않고 반드시 오버라이딩 하게끔 하려면
	다음과 같이 추상메소드로 만들어야 해요!
	
	abstract public void clacArea();
	이러한 메소드를 "추상메소드"라고 합니다.

	이와같이 어떤 클래스가 추상메소드를 하나라도 갖고 있다면,
	그 클래스 자신이 추상 클래스가 되어야 해요!

추상이라는 말은 무엇인가 구체화 되지 않은 상태를 말합니다.
==>추상클래스의 객체는 생성할 수 없어요!!!!!!!

<< 추상클래스와 추상메소드 >>
미래에 만들어질 자식클래스들이 가져야할 공통적인 속성과 동작을 뽑아서
미리 부모클래스를 만들어 이 때 어떠한 메소드를 구체화 할 수 없어요.
그러나 이 메소드는 반드시 자식클래스들이 가져야하며. 오버라이딩 할 것을 강제화 하고싶어요.
이때 이러한 메소드에는 body를 구체화하지 않고 메소드 선언문만 하고,추상메소드를 만들어요,\.
이때 메소드명 앞에 추상메소드임을 표시하기 위한 abstract 이라는 키워드를 붙여요.
이와같이 어떤 클래스가 추상메소드를 하나라도 갖고 있다면
그 클래스 자신이 추상클래스가 되어야해요!

또, 추상클래스는 body가 구체화되지 않은 메소드를 갖고있기 때문에 객체를 설정할 수 없어요.


<< equal메소드(day1219) >>====================================================================
기본자료형의 값이 서로 같은지 판별하기 위해서는 (==)
그런데 만약 참조자료형에 (==) 연산자를 사용하게되면 
	둘이 같은 메로리를 바라보는지 검사해요.
	두개의 객체가 서로 동일한 값을 갖고 있어도 
	false를 반환해요.

	만약, 두개의 객체가 서로 동일한 속성값을 갖고 있는지
	판별하려면 자바의 제일 조상인 Object equals를
	나(class)한테 맞게 재정의 해요!!!!

<< final(day1219) >>==========================================================================
final 키워드는
	맴버변수명 앞에		값 변경금지(상수)		
	멤버메소드 앞에		오버라이딩 금지
	클래스 이름 앞에	상속 금지

	-----> final은 static과 같이 사용해요!

<< interface(day1219) >>======================================================================
interface 
==> 자바는 클래스의 다중상속이 금지되어있어요.
	다중상속의 효과를 기대할 목적으로 인터페이스를 사용해요.

class 클래스이름
{

...

}

interface 인터페이스(목적:다중상속할라고)
{


}

==> 인터페이스는 완전추상의 개념입니다.
	인터페이스는 추상메소드와 상수만으로 구성되어야 해요.(바디가있는 메소드는 올 수 없음)
	
	메소드선언부만 오고 메소드이름앞에 abstract을 생략할 수 있다.
		'abstract메소드' 가 디폴트값이다.
	변수명 앞에 final을 쓰지않아도 된다. 
		'final변수' 가 디폴트값이다.

<< 부모클래스의 참조변수 >>==============================================================
상속관계에 있을때 부모클래스의 참조변수는 
	자식객체를 생성하거나 
	참조할 수 있어요.

<< 부모클래스의 참조변수와 자식객체 >> ==================================================
부모 클래스의 참조변수는 
	상속관계에 있는 자식객체를 참조할(만들수) 수 있어요.
	/이때 부모클래스의 참조변수를 통해 메소드를 호출할 때/
	만약 어떠한 메소드가 부모클래스에도 있고, 자식 클래스에도 동일한 이름의 메소드가 있다면
	(즉, 오버라이딩 한 메소드가 있다면)
	이 참조변수가 바라보는 객체를 평가하여 그 객체가 갖고있는(자식이 갖고있는)
	===>오버라이딩한 메소드가 호출되어요.

그런데!!
	부모클래스에는 없고 자식클래스에서 추가된 메소드를 호출하려면 
	그 자식클래스의 자료형으로 형변환 한 후 호출할 수 있어요!

그리고 이때!
	특정 클래스형의 자료형(여러개의 자식클래스)인지 판별하여 형변환 할 필요가 있는데
	이때 사용하는 연산자가 'instanceof' 연산자 입니다.

	자식클래스를 객체로 사용하고서 자료형이 맞는지 확인하기위해 instanceof사용

	if(a instanceof Shape){		/a야 너 Shape자료형에있는 메소드 쓸래???????????
		((Shape)a).clacArea();	/a엔 없지만 Shape에 있는 calcArea메소드를 쓰겠다...
	}
=========================================================================
인스턴스
==> 하나의 클래스를 복제해서 서로다른 데이터의 값과 서로같은 메소드를 가진 복제본이다.
=========================================================================



this
	==> 생성자나 메소드의 매개변수 이름을 의미있는 이름으로 정해주다보면
		클래스맴버변수 이름과 같아지게되어요!
		이때, 멤버 자신을 구별한 목적으로 this를 사용한다.

this()
	==> 생성자가 중복정의되어 있을때 나 말고 다른 생성자를
		동작시키고자할때(호출) 사용하는 키워드입니다.

	!!!!! this()키워드는 반드시 생성자의 첫번째 문장에 와야 합니다.

