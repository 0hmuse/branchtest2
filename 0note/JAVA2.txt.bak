CUI	Character User Interface
GUI	Graphic User Interface		java.awt

=========================================================================================

-문자열 처리
	String
	StringBuffer



<< 예외(Exception)처리 >>================================================================

사용자의 부주의등으로 예기치 않는 상황이 발생하는것을
	"예외"라고 하고

	그것에 대한 처리를
	"예외 처리"라고 한다.

자바는 대부분의 일반적인 예외에 대해서 이미 만들어져 있어요.
일반적인 상황에 대해서 예외 클래스가 만들어 져 있어요.
즉, 특정 예외 상황이 되면 자바는 예외 객체를 생성하여 예외를 발생시켜요!

<< 예외 처리 방법 >>
try{
	예외가 발생할 만한 문장들.....
	......
	......
}catch( 예외자료형 변수명 ){
	예외가 발생되었을때 처리할 문장들.....
}catch(여러개의 catch가 올 수 있다.){
}

==> 여러개의 catch를 사용할때는 범위가 작은것 부터 와야함.


<< RuntimeException >>
프로그램 실행중에 발생하는 예외를 말하여
사용자가 특별히 예외처리하지 않아도 자바가 예외처리 해 줍니다.


RuntimeException이 아닌것들은 반드시 사용자가 예외처리를 해야해요.
(RuntimeException의 후손이 아닌것들)
하지않으면 컴파일오류를 발생시킨다.
==> 만약 예외처리 하지 않는다면 컴파일 되지 않아요!

대표적인 예외처리해주어야 할것들
java.io(입출력)		의 대부분 클래스의 생성자와 메소드
java.net(네크워크)	의 대부분 클래스의 생성자와 메소드

!!! ==> 메소드를 호출할때 처리해줄 수도 있음(day1224 ExceptionTest02)

<< throw >>====================================================================
강제로 예외를 발생시키는 키워드 입니다.

<< 사용자 정의 예외 >>=========================================================
자바 프로그램에서 보편적인 예외에 대해서는 미리 클래스화 되어있습니다.
그러나 어떤 특정한 상황을 예외로 만들고자 한다면
사용자가 예외를 정의할 수 있어요.

이러한 사용자 정의 예외는 그러한 상황이 되어도 자바가 몰라요.
그래서 우리가 강제로 예외를 발생시켜야 해요.
	! throw라는 키워드 사용 !
==> throw new 사용자정의예외명();

<< 사용자 정의 예외 만드는 방법 >>=============================================

class 예외클래스이름 extends Exception{
	public 예외클래스이름(String msg){
		super(msg);
	}
}

<< finally >>==================================================================
예외가 발생하거나 정상적으로 처리되거나 반드시 동작시켜야 할 내용이 있다면
finally에 기술합니다.





====자바의 동적배열(컬렉션프레임워크)(Set, List, Map) java.util==========================

많은 양의 자료처리를 위해서는 일반적으로 배열을 사용합니다.
그러나 배열은 다음의 단점을 갖고 있어요!
	1. 자료형이 동일한 것만 담을 수 있어요.
	2. 자료의 추가, 삭제가 번거로워요.
	
이러한 단점을 해결하기 위하여 컬렉션프레임워크를 사용해요.
컬렉션 프레임워크의 종류 Set, List ,Map 3가지가 있어요.

Set	- 자료의 중복을 허용하지 않아요. 
		/ HashSet	-데이터의 입력순서를 무시 
		/ LinkedHashSet,-데이터의 입력순서를 유지
		/ TreeSet	-데이터의 크기에 따라 정렬
	
List	- 인덱스에 의해 데이터에 접근함.
	  자료의순서를 유지하고, 중복을 허용해요. 
	  둘다 사용법은 동일해요. 그러나 내부적으로 동작하는 방식이 다르다.
	  (데이터 중간에 추가하거나 삭제할때)
		/ ArrayList	-중간에 데이터추가,삭제가 이루어지면 새로운 배열이 필요하다. 
					일일이 자리이동을 합니다.
		/ LinkedList	-그래서 중간에 데이터추가,삭제가많으면 LinkedList가 더 효율적이다
				(자료의 데이터값뿐만 아니다 전후의 데이터주소를 함께 가지고 있기때문에
					추가,삭제시 관련있는 데이터의 주소만 변경해주면 된다)

Map	- key와 value가 한 쌍으로 이루어진 자료구조이다.
	  (((( key값을 기준으로 정렬 )))
		/ HashMap	-  
		/ LinkedHashMap	-
		/ TreeHashMap	-

Set, List, Map 모두 인터페이스
	이것들을 구현한 다양한 클래스들이 있어요!

<< 제네릭 >>=============================================================================
자바 초기에는 컬렉션 프레임웤에 온갖 자료형을 담을 수 있는 것이 장점이였으나
이것이 현재에는 단점이 되어 컬렉션 프레임웤에 담을 수 있는 데이터타입을 제한하고
사용하기를 권장합니다. 이것을 "제네릭" 이라고 합니다.

exam) -> eclipse day1223
ArrayList list = new ArrayList();
list.add("귤");
list.add(23);
list.add(new Person("홍길동", 20);
list.add(new Person("이순신", 40);
list.add(true);

==> 위의 list의 첫번째 요소는 String,두번째 요소는 정수형
	세번째, 네번째 요소는 Person형 등
	다양한 자료형이 담겨 있어요.
list의 자료를 담기만 하고 끝나는 것이 아니라 list에 담긴 자료형을 하나씩 꺼내와서 어떤 일처리를 해야할때
이것들의 자료형이 마구 섞여있어 불편을 초래해요.
만약 담긴 자료형이 Person이라면 sayHello 메소드를 호출하고자 한다면
또, 담긴 자료형의 정수형이 모두 누적을 한다면
일일이 그 꺼내온 자료형이 어떤 자료형인지 검사해야해요.
그래서, 현재의 자바에서는 
===>컬렉션 프레임웤에 담는 자료형을 특정자료형으로 제한하기를 권장합니다.
ArrayList<Person> = new ArrayList<Person>();
위와같이 표현하면 list에 담는 자료형을 Person으로 제한하겠다라는 의미이다.


<< Mrapper 클래스 >>=====================================================================
ArryList<int>=new ArrayList<int>();	X
ArryList<integer>=new ArrayList<integer>();	OK

기본자료형을 참조자료형(객체)로 만들어 주는 클래스들을 말합니다.
서로다른 자료형끼리의 형변환을 위해서 Wrapper클래스를 사용합니다.

자바가 제공하는 어떠한 기능을 사용할 때
	기본자료형을 취급하지 않고 객체만 상대하는 메소드들이 있어요.
	이런 메소드를 사용하려면 Wrapper클래스를 이용하여 
	==> 기본자료형의 데이터를객체로 만들어야 해요.(객체화 시켜야한다)
	//<객체>//

boolean		->	Boolean
char		->	Character
byte		->	Byte
short		->	Short
int		->	Integer
ling		->	Long
float		->	Float
double		->	Double

<< 클래스 사이의 관계 >> ================================================================

- is a 관계
    상속관계에 있는 것을 말합니다.
    이미 있는 클래스를 확장하여 자식클래스를 만드는 것을 말합니다.


- has a 관계
    이미 있는 다른 클래스를 멤버변수로 갖는 것을 말합니다.


-자바의 유용한 클래스들~

-파일처리

-네트워크 프로그래밍

-데이터베이스(db) 연결프로그래밍

-GUI 프로그래밍




day0205 com.bit.test
*** 게시판 만들기

*** 메소드 오버로딩에 대하여 설명하세요(메소드중복)
--> 동일한 이름의 메소드를 만들수 있다(중복하여 정의)
	단, 매개변수의 갯수나 매개변수의 자료형이 달라야한다


*** 메소드 오버라이딩에 대하여 설명하세요
--> 메소드 재정의를 꼭 해야함
	(인터페이스를 상속받았을때 추상메소드를 재정의 해야함)
==> 상속관계에 있을때 부모의 메소드를 자식클래서에 맞도록 재정의 하는것을 말합니다.
	단, 메소드 이름뿐 아니라 매개변수의 개수와 자료형 같아야한다


*** 자바 세상에서 모든 클래스들은 Object의 후손입니다.
예를 들어 다음과 같은 클래스 정의가 있다고 가정합니다.
class Person{			<===	class Person extends Object
	private String name;
	private int age;
}
--> 위에서 정의한 Person은 Object의 후손입니다.
	따라서 필요하다면 Object의 메소드를 Person에 맞도록 재정의 할 수 있어요.
    일반적으로 Object의 메소드중
    toString(), equals()메소드를 자식클래스에 맞도록 재정의 많이 합니다.

------------------------------------------------------------------------------------
*** toString()에 대해 설명하세요
	--> 여러개의 문자열(문자)을 한 덩어리로 만들어서 String으로 반환한다...?

*** equals()에 대해 설명하세요
    	--> 문자열 그 안에 내용(속성)이 동일한지 판별하여 참거짓을 반환한다.
------------------------------------------------------------------------------------
==> 


'==' 은 기본자료형일때 같을때 물어본다

참조자료형(객체)에서 '=='을 하면 같은곳(주소)를 바라보는지 물어보는것
그래서 equals를 사용해서 그 객체의 속성이 같은지를 확인해야한다


*** 추상클래스
	미래에 만들어질 후손들이 가져야할 속성과 동작을 일반화 함에 있어
	어떠한 메소드를 구체화 할 수 없는 경우에 메소드 선언부만 명시해요
	이러한 메소드를 추상메소드라 하며, 추상메소드를 하나라도 갖고있는 클래스는
	추상 클래스가 되어야 합니다.
	추상메소드와 추상클래스 앞에 abstract키워드를 붙여야 합니다.

*** 인터페이스
	자바는 클래스의 다중상속이 금지되어있습니다.
	다중상속의 효과를 기대할 목적으로 인터페이스를 이용합니다.
	인터페이스는 완전추상의 개념으로 
	추사클래스와 달리 추상메소드와 상수만으로 구성되어야 합니다.
	
	메소드명 앞에 abstract을 생략해도 됩니다.
	상수명 앞에 final을 생략해도 됩니다.


*** 자바의 프레임워크의 종류
- Set	==> 데이터의 중복을 허용하지 않아요
- List	==> 데이터의 중복을 허용해요
- Map	==> key와 value가 한쌍으로 이루어진 자료구조이며
		key를 통해 데이터에 접근해요

---> Set이용하여 로또만들기

TreeSet lotto = new TreeSet();
// 중복을 허용하지 않는 set을 생성한다.
Random r = new Random();
// 1~45사이의 난수를 만들기위한 랜덤객체 생성.
while(true){	// 계속(끝없이)반복시행해요.
	lotto.add(r.nextInt(45)+1);
	if(lotto.size()>=6){	// 만약 set이름인 lotto의 담긴 수(size)가 6개 이상이면 반복문을 탈출해요.
		break;
		}
	}		
System.out.println(lotto);
// set의 변수인 lotto에 담긴 6개의 번호를 출력해준다.
// TreeSet에 toString()이 자신에게 맞도록 재정의 되어 있어요.
System.out.println(lotto.toString());

*** instance do 연산자
is a 관게에 있는지 판별하는 연산자 입니다.
어떠한 참조변수가 특정 클래스의 자료형인지 판별하는 연산자 입니다.
	
