CUI	Character User Interface
GUI	Graphic User Interface		java.awt

=========================================================================================

-문자열 처리
	String
	StringBuffer



-예외처리



----자바의 동적배열(컬렉션프레임워크)(Set, List, Map) java.util==========================

많은 양의 자료처리를 위해서는 일반적으로 배열을 사용합니다.
그러나 배열은 다음의 단점을 갖고 있어요!
	1. 자료형이 동일한 것만 담을 수 있어요.
	2. 자료의 추가, 삭제가 번거로워요.
	
이러한 단점을 해결하기 위하여 컬렉션프레임워크를 사용해요.
컬렉션 프레임워크의 종류 Set, List ,Map 3가지가 있어요.

Set	- 자료의 중복을 허용하지 않아요. 
		/ HashSet	-데이터의 입력순서를 무시 
		/ LinkedHashSet, -데이터의 입력순서를 유지
		/ TreeSet	-데이터의 크기에 따라 정렬
	
List	- 자료의순서를 유지하고, 중복을 허용해요. 
	  둘다 사용법은 동일해요. 그러나 내부적으로 동작하는 방식이 다르다.
	  (데이터 중간에 추가하거나 삭제할때)
		/ ArrayList	-중간에 데이터추가,삭제가 이루어지면 새로운 배열이 필요하다. 
					일일이 자리이동을 합니다.
		/ LinkedList	-그래서 중간에 데이터추가,삭제가많으면 LinkedList가 더 효율적이다
				(자료의 데이터값뿐만 아니다 전후의 데이터주소를 함께 가지고 있기때문에
					추가,삭제시 관련있는 데이터의 주소만 변경해주면 된다)

Map	- key와 value가 한 쌍으로 이루어진 자료구조이다. 
		/ HashMap	  
		/ LinkedHashMap

Set, List, Map 모두 인터페이스
	이것들을 구현한 다양한 클래스들이 있어요!

=========================================================================================

-자바의 유용한 클래스들~



---파일처리 =============================================================================
(day0106 exam11)


---네트워크 프로그래밍 ==================================================================
자바는 네트워크 프로그래밍을 위해여 관련클래스들을 다음패키지에서 제공합니다.
java.net

<< Stream >>=============================================================================
	==> 순서가 있는 자료의 흐름





-데이터베이스(db) 연결프로그래밍



---GUI 프로그래밍========================================================================
자바는 GUI프로그래밍을 위하여
	java.awt		처음부터 제공
	javax.swing		jdk 1.4이후에 추가



<< Layout Manager >>=====================================================================
GUI프로그래밍에서 화면의 구성요소들을 배치하는 방식

1) FlowLayout
	==> 화면 구성요소들을 자동으로  왼쪽에서 오른쪽으로 
					위에서 아래로 배치하는 방식

2) GridLayout
	==> 화면을 행열로 분할하여 차례대로 구성요소들을 배치하는 방식


3) BorderLayout
	==> 화면을 위,아래,좌,우,가운데 5개영역으로 분할하여 
			중요한것을 가운데에 위치하는 방식

====> 이러한 LayoutManager가 중첩되어 사용할 수 있어요.


<< 그림판 만들기 >>======================================================================
자바에서 일반적으로 그래픽을 표현하기 위해서는
	JPanel을 확장하여 새로운 클래스를 만들어요.

	그래픽을 표현하기 위한 메소드
		paint메소드를 오버라이딩하여 그래픽을 표현합니다

이렇게 만들어진
	Panel을 Frame의 구성요소로 표현합니다.

<< JTable >>=============================================================================


<< DATA BASE >>==========================================================================
데이터베이스의 필요성
	==> 프로그램 실행결과를 영구적으로 지정하기 위해서는
	    "파일"을 이용합니다.

	그러나 "파일"은 이해관계에 있는 다수사용자가 동시에 최신의 정보를 공유하기에 
	어려움이 있습니다.
	이것을 위하여 "데이터베이스"를 이용합니다.

"데이터베이스"는 자료를 쌍아놓은 더미라고 생각합니다.
이러한 데이터를 쌓아놓은 더미를 관리하는 시스템이 필요해요.(프로그램)

==> 데이터베이스 관리 시스템(DataBase Managment System : DBMS)
	(JAVA와연결하기)
DBMS의 종류
-> mssql
-> mysql
-> oracle

	c:\>sqlplus
	암호입력:manager

	sql>create user c##bit identified by bit;	
			->사용자이름	     ->암호
	c:\sqlplus
	userName:c## bit
	password:bit

=========================================================================================

	sqlplus
	system
	manager

	SQL> conn c##bit/bit	

	sql>create table student(		<- 테이블만들기
			name varchar2(20) primary key,
			kor number,		->중복안되게 제약을 건다(pk)
			eng number,
			math number);
	
삽입	insert into student values('홍길동',80,90류,100);		<- 데이터넣기

	commit; ((save같은거

	select * from student; (모든표 보여줘)
테이블	drop table student;
삭제


수정	update student set kor=50,eng=50,math=50 where name='지연';
삭제	delete student where name='유관순';


<< 멀티 Thread 프로그래밍 >>=============================================================
(day0103 exam 2~)
	==> 가능하면 두개이상의 객체가 동시에 어떤 일을 수행하도록 하게끔 하는 프로그래밍

(Interface)
	-Thread(extends)
	-Runnable(implements)
		==> run메소드 오버라이딩 (해야함)
		    그 안에 공평하게 실행시키고자 하는 명령어들을 작성.
		    ((Thread.sleep(long millis)); 메소드는 예외를 갖고있음)

*** 쓰래드를 가동 ***
	run()을 직접 호출 ==> 일반메소드 취급함!!!!!
	* start()로 호출!!
	

Thread 각각의 객체를 만들어서 가동시킬 수 있음.
가급적이면 공평하게 실행되어요!!(시스템상황에 따라 달라짐)
	늘 언제나 1:1로 동작하는것은 아님.



Runnable 인터페이스는(Thread처럼 run메소드오버라이딩) 
	body가 구체화된 start()메소드가 없어요.		Thread(Runnable target) <- 생성자모양.
	*** 그래서 Thread클래스를 통해서 가동해요. (ex  Thread t1 = new Thread(p1);
						        t1.start();)
							
						
<< Thread의 우선순위 설정 >>=============================================================
(( 가능하다면~ 
set.Priority(새로운 우선순위(정수)) 1~10
	public static final int		MAX_PRIORITY	10
	public static final int		MIN_PRIORITY	1
	public static final int		NORM_PRIORITY	5

Thread.MIN_PRIORITY();	=> 1
Thread.MAX_PRIORITY();	=> 10	<-최고우선순위( 로 설정했다고 하여 
							반드시 그 작업이 
							먼저 완료되는것을 보장하지는 않는다!
							먼저 그 작업을 해달라고 요청하는것일뿐!)

<< Thread사이의 통신 >>==================================================================
반드시 1:1로 실행해야 할 때가 있다!!! Thread간의 통신.
ex 생산->소비(day0106 exam08)
	생산자가 제품을 생산해야지만 소비자가 제품을 소비하도록 하고
	소비자가 제품을 소비해야지만 새로운 제품을 생산하도록 하려고합니다.
	--> 제품을 새로운 정수로 나타내봅시다!


Class Object -> wait() 과 notify()이용하여 Thread사이의 통신을 표현할 수 있다.

< 임계영역(Critical Section) >===========================================================
(day0106 exam09)
"java.lang.IllegalMonitorStateException" 오류가 난다
두개이상의 Thread가 공유하는 자원으로써 
	한번에 하나의 쓰레드에게만 접근을 허용하는 영역을 말한다
	(제품을 생산하고있는데 소비하려고 접근할때 오류가남)

임계영역을 위해서 임계영역에 접근하는 메소드 앞에
synchronized키워드를 붙여서 
	한번에 하나의 쓰레드에게만 접근을 허용할 수 있어요



<< 네트워크 통신 프로그램 >>=============================================================
(day0107)
1. TCP (Transmission Control Protocol) / 연결 지향프로그램 ex)전화
	- 데이터가 상대방에게 잘 전달되었는지 확인메세지를 교환하시 때문에
		==> 데이터손실이 없다
			연결 설정 후 정보를 전달하기 때문에 데이터의 전달순서가 보장된다.
	- 그러나 연결과 해제의 시간적 부담이 발생한다

2. UDP (User Datagram Protocol) / 비연결 지향프로그램 ex)편지
	- 데이터의 전달 여부를 확인하지않고 데이터를 전달해준다
		==> 데이터 손실이 발생할 수 있다.
			데이터마다 전달 경로가 달라질 수 있기때문에 전달순서가 보장되지 않는다.

3. IPAddress 
	- 인터넷에 연결된 각 컴퓨터마다 고유의 번호가 있다.


4. port
	- 네트워크 카드가 하나인 서버컴퓨터라도 다수의 서버 프로그램을 실행 할 수 있다.
		하지만 하나의 IP주소가 부여되므로 다수의 서버프로그램을 동시에 실행하려면,
		어느 서버 프로그램과 통신할지 선택해야한다! 
		==> port번호사용!(0~65,535)
	- 한 회사 건물의 부서 이름같은 느낌...
-----------------------------------------------------------------------------------------

멀리 떨어진 원격지의 두대이상의 컴퓨터가 서로 데이터를 주고받는 프로그램

< ipAddress >
네트워크 상에 수많은 컴퓨터들 중에 통신을 위한 대상을 구별하기 위한 식별자

ip주소 확인하기 위해서
c:/>ipconfig
192.168.0.21

< port번호 >
하나의 컴퓨터에서는 여러개의 네트워크 프로그램이 동시에 실행 될 수도 있어요.
특정 네트워크 프로그램을 구별하기 위한 식별자 역할
/1521,8080,80 등등
192.168.0.21:1521	oracle
192.168.0.21:8080
192.168.0.21:80

java.net
<< TCP방식 >>----------------------------------------------------------------------------
			   (대상 컴퓨터의 ip주소와 port번호가 필요함)
데이터를 주고받을 컴퓨터와 연결을 먼저 맺은 후
그 연결된 회선을 통하여 데이터를 주고 받는 방식
네트워크 부담은 높지만, 신뢰성이 보장된다(데이터손실X).

     TCP방식을 위하여 자바가 제공하는 클래스
	ServerSocket
	Socket

- 생성자
ServerSocket(int port)
Socket(String host, int port)
Socket(InetAddress address, int port)
... 등등

- 메소드
accept()		retrun Socket
getOutputStream()	OutputStream
... 등등

< 서버와 클라이언트 >
서버(Server) 네트워크 상에서 어떤 서비스를 제공하는 컴퓨터 혹은 프로그램
클라이언트(Client) 네트워크 상에서 어떤 서비스를 (사용하는)제공받는 컴퓨터 혹은 프로그램

///////////////////////////////////////////////////////////////////////////////////////////////////
** 서버는 클라이언트가 접속하면 난수 10개를 생성하여 클라이언트에게 내보내는 프로그램작성하기
(day0107 - editplus/TCPServer, TCPClient)
< TCP 방식의 네트워크 프로그램 절차 >
	ServerSocket
	Socket

	| Server |					| Client |
1.  ServerSocket을 생성한다			
2.  클라이언트의 접속을 위하여 
	무한대기상태로 있는다
3.						Socket객체를 생성하여
							서버에게 접속을 요청한다
4. 클라이언트의 접속을 수락한다
	accept() 호출되고
	Socket(클라이언트와 통신하려는 소켓)
	을 반환한다
	=> 클라이언트와 데이터를 주고받을
			(데이터 소켓)
5. 데이터를 주고받을 Stream을 생성한다		데이터를 주고받을 Stream을 생성한다
6. 데이터를 주고 받는다				데이터를 주고 받는다
7. 사용했던 자원을 닫아준다			사용했던 자원을 닫아준다


C:\JavaStudy\day0107>java TCPClient
Connection refused: connect		--> 서버가 안열렸는데 접속하려고 하면 오류가 난다!

///////////////////////////////////////////////////////////////////////////////////////////////////


<< UDP방식 >>----------------------------------------------------------------------------
데이터를 받은 컴퓨터의 상태를 확인(컴퓨터와 연결)하지 않고 데이터를 보내는 방식
네트워크 부담은 적지만, 신뢰성이 보장되지 않는다(데이터 손실이 있을 수 있다).

	보내는 데이터마다 갈 목적지의 ip주소 port번호 데이터를 묶어서(패킷)
	단위로 묶어서 보낸다

	패킷 : 목적지의 주소ip + port번호 + 데이터

     UDP방식을 위하여 자바가 제공하는 클래스
	DatagramSoket
	DatagramPacket


** UDPReceiver(server) UDPSender(client)
< UDP 방식의 네트워크 프로그램 절차 >

DaragramSocket
	==> 데이터를 주고 받는 기능 제공
		void	receive(DatagramPacket p) -> 데이터받기(보낸사람의 정보도 들어있음)
		void	send(DatagramPacket p) -> 데이터보내기


DatagramPacket
	==> 데이터를 주고 받는 단위
		(데이터+목적지주소+port번호)
DatagramSocket(int port)
DatagramPacket(byte[] buf, int length) 받을때 생성자

///////////////////////////////////////////////////////////////////////////////////////////////////
** 다음과 같이 UDPSender가 보내준 데이터를 UDPSender는 받아서 화면에 출력하도록 프로그램 해 보자
(day0107 - editplus/TCPChatServer, TCPClientGUI)
UDPReceiver
java UDPSender 192.168.0.21 9001 안녕
		ip	    port data


UDPSender는 받아서 화면에 출력하도록 프로그램 


DatagramPacket(byte[] buf, int length, InetAddress address, int port)